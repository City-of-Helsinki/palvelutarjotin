import logging

from anymail.signals import pre_send
from django.core.exceptions import ObjectDoesNotExist
from django.db import transaction
from django.db.models.signals import m2m_changed, post_delete, post_save
from django.dispatch import receiver
from occurrences.consts import NotificationTemplate
from occurrences.event_api_services import (
    send_event_languages_update,
    send_event_republish,
    send_event_unpublish,
)
from occurrences.models import Enrolment, Occurrence
from occurrences.utils import send_event_notifications_to_person

from common.utils import format_linked_event_datetime
from palvelutarjotin.exceptions import ObjectDoesNotExistError

logger = logging.getLogger(__name__)


@receiver(post_save, sender=Enrolment, dispatch_uid="send_enrolment_email")
def send_enrolment_email(instance, created, **kwargs):
    # Do not sent enrolment received notification if the occurrence auto accept the
    # enrolment, instead only send enrolment approved notification
    if created and not instance.occurrence.p_event.auto_acceptance:
        send_event_notifications_to_person(
            instance.person,
            instance.occurrence,
            instance.study_group,
            instance.notification_type,
            NotificationTemplate.OCCURRENCE_ENROLMENT,
            NotificationTemplate.OCCURRENCE_ENROLMENT_SMS,
            event=instance.occurrence.p_event.get_event_data(),
            enrolment=instance,
        )


@receiver(post_delete, sender=Enrolment, dispatch_uid="send_unenrolment_email")
def send_unenrolment_email(instance, **kwargs):
    send_event_notifications_to_person(
        instance.person,
        instance.occurrence,
        instance.study_group,
        instance.notification_type,
        NotificationTemplate.OCCURRENCE_UNENROLMENT,
        NotificationTemplate.OCCURRENCE_UNENROLMENT_SMS,
        event=instance.occurrence.p_event.get_event_data(),
        enrolment=instance,
    )


@receiver(pre_send)
def remove_message_id(sender, message, **kwargs):
    # We need to remove the already generated Message-ID and let it be generated by the
    # ESP in order to avoid the message being identified as spam by some strict
    # filters.
    message.extra_headers.pop("Message-ID", None)


@receiver([m2m_changed], sender=Occurrence.languages.through)
@transaction.atomic
def update_event_languages(sender, instance, action, pk_set, **kwargs):
    """
    When occurrence languages updates,
    the languages should be synced to LinkedEvents Event languages.

    NOTE: This will be called once by remove actions and once by additions.
    """
    # Ignore other actions than post actions
    if action not in ["post_clear", "post_remove", "post_add"]:
        return

    # Current languages set to an event.
    # Note that on post_delete, the object will no longer be in the database.
    event_language_ids = [
        language.id
        for language in instance.p_event.get_event_languages_from_occurrence()
    ]

    # If a removed language still exists on other occurrence,
    # avoid sending a redundant update,
    # which doesn't actualyl change anything.
    if action == "post_remove" and all(
        language in event_language_ids for language in pk_set
    ):
        return

    # Send the updated languages to LinkedEvent
    send_event_languages_update(instance.p_event, event_language_ids)


@receiver([post_delete], sender=Occurrence)
@transaction.atomic
def update_event_languages_on_occurrence_delete(sender, instance, **kwargs):
    """
    When an occurrence is deleted,
    the remaining occurrences languages should be synced to LinkedEvents
    Event languages.
    """
    try:
        if not hasattr(instance, "p_event"):
            return
    except ObjectDoesNotExist:
        return

    # Current languages set to an event.
    # Note that on post_delete, the object will no longer be in the database.
    event_language_ids = [
        language.id
        for language in instance.p_event.get_event_languages_from_occurrence()
    ]
    # Send the updated languages to LinkedEvent
    try:
        send_event_languages_update(instance.p_event, event_language_ids)
    except ObjectDoesNotExistError as err:
        logger.warning(
            "An ObjectDoesNotExistError was raised, but the update process continued,"
            + "because data is being deleted, not updated. Error: {0}".format(err)
        )


@receiver(post_save, sender=Occurrence)
@transaction.atomic
def republish_event_to_sync_times_on_save(sender, instance, created, **kwargs):
    """
    Republish the event end time to LinkedEvents API when an occurrence is saved
    and linked to a published event.
    NOTE: `The graphene_linked_events.PublishEventMutation` and
    `graphene_linked_events._prepare_published_event_data`
    sets the start time of the event to time it is at the moment of the publishment.
    That should not be changed here in this signal! Also, since it would be pure
    nonsense to add an occurrence to the past, the occurrence handled in this signal
    should never change the start time of the event
    """

    event_time_range_changed = False
    if not created:
        # The status of occurrences before the save process has finished.
        occurrences = instance.p_event.occurrences.filter(cancelled=False).order_by(
            "start_time"
        )

        # Fetch data from LinkedEvents API.
        # FIXME: The changes of the time fields should be checked,
        # to prevent duplicate signal calls (1 from create, 1 from relation updates),
        # but in a post_save-signal the information is not available
        # and in a pre_save-signal the occurrences are not yet persisted,
        # so it would be a pain to republish by using
        # send_event_republish (and p_event.get_end_time_from_occurrences())
        # TODO: Effective cache should be used
        event = instance.p_event.get_event_data()

        if not event:
            return

        # If first or last occurrence of the event and affects on event time range.
        if (
            instance == occurrences.first()
            and not event.start_time
            == format_linked_event_datetime(instance.start_time)
        ) or (
            instance == occurrences.last()
            and not event.end_time == format_linked_event_datetime(instance.end_time)
        ):

            # Event start time or end time has changed
            event_time_range_changed = True

    if (
        # Newly created or needs update for times...
        (created is True or event_time_range_changed is True)
        # Published (in LinkedEvents API)
        and instance.p_event.is_published()
    ):
        # Republish
        send_event_republish(instance.p_event)


@receiver(post_delete, sender=Occurrence)
@transaction.atomic
def republish_event_to_sync_times_on_delete(sender, instance, **kwargs):
    """
    If the event is published,
    handle the event update of last existing occurrence
    by calling "unpublish" which means resetting the end time of the event.
    """
    if (
        instance.p_event.is_published()
        and instance.p_event.occurrences.filter(cancelled=False).count() == 0
    ):
        send_event_unpublish(instance.p_event)
